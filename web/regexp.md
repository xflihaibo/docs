# 正则表达式

**正则表达式：** 又称规则表达式。（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。

## 基本元字符

1.  .： 匹配除了换行符之外的任何单个字符
2.  \ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\的'b'通常匹配小写'b'，无论它们出现在哪里。如果加了'\',这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\*/ 将 '*' 的特殊性移除，从而可以匹配像 "a\*" 这样的字符串。
3.  | ： 逻辑或操作符
4.  [] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\这些字符都表示其本身,(（）: 多字节 不可转义 []:单字节 可转义)
5.  [^]：对上面一个集合取非
6.  -   ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面

## 数量元字符

1.  {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次
2.  \+ ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次
3.  \* ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(\*)，可以一次都没有
4.  ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词\*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"。

## 位置元字符

1.  ^ ： 单独使用匹配表达式的开始
2.  \$ ： 匹配表达式的结束
3.  \b：匹配单词边界
4.  \B：匹配非单词边界
5.  (?=p)：匹配 p 前面的位置
6.  (?!p)：匹配不是 p 前面的位置

!>注：使用 “m“，”^” 和 “$” 将会从只匹配正则字符串的开头或结尾，变为匹配字符串中任一行的开头或结尾。

## 特殊元字符

1.  \d：[0-9]，表示一位数字，记忆方式 digit
2.  \D：[^0-9]，表示一位非数字
3.  \s：[\t\v\n\r\f]，表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），记忆方式 space character
4.  \S：[^\t\v\n\r\f]，表示非空白符
5.  \w：[0-9a-zA-Z_]，表示数字大小写字母和下划线，记忆方式 word
6.  \W：[^0-9a-za-z]，表示非单词字符

## 标志字符

1.  g : 全局搜索 记忆方式 global
2.  i ：不区分大小写 记忆方式 ignore
3.  m ：多行搜索

```javascript
() :优先
```

## 贪婪懒惰

!>正则默认是贪婪模式 量词后面加 `?` 是懒惰模式

## 正则分组

### 正则分组作用：

1.  改变优先级
2.  分组引用
3.  分组捕获

### 改变优先级

```javascript
var reg = /^x|y$/;
var regg = /^(x|y)$/;
var str = 'x1';
reg.test(str); // true,这里其实匹配以x开头或者以y结尾
regg.test(str); // false,这里其实匹配x或者y
```

### 分组引用

\2. 表示第二个分组,\1 表示第一个分组,但是\2 必须在出现在第二个分组的后面,因为只有知道第二个分组是,我才知道\2 是啥
这里特别注意,\2 的内容和第二个分组的内容必须一模一样

```javascript
var reg = /(\d)([a-z])\1([A-Z])\2/;
// 这里有3个分组,\1可以等价于(\d)所表示的值,也就\d表示2,那么\1也就只能是2而不能是3

var str = '4a4Aa';
var str1 = '4a3Aa';
reg.test(str); // true
reg.test(str); // false 这里的\1只能是4
```

### 分组捕获

正则捕获的时候不仅把大正则匹配的内容捕获到还能把小正则的内容捕获到还有一个规则要记得,(?:)在分组中?:的意思是只匹配不捕获,注意的是如果用了这个,表示这个分组就不会产生引用

```javascript
var reg = /(\d)(?:[a-z])([A-Z])\2/;
// 这里的第二个分组用了?:,所以不产生引用,也就\2表示第三个分组([A-Z])
reg.test('1aAA'); // true
reg.test('1aAa'); // false

//exec
var reg = /(\d)(?:[a-z])([A-Z])\2/;
reg.exec('1aAA'); // ["1aAA", "1", "A"]
//第一项表示大正则,接下来就是小正则也就是小分组的内容
'1aAA'.match(reg); // ["1aAA"]
// 也就是match只能匹配大正则的内容

/(\d)(?:[a-z])([A-Z](0))\2(p)/.exec('1aA0A0p'); // ["1aA0A0p", "1", "A0", "0", "p"]
// 有小括号a套小括号b的时候,会先小括号a,然后再小括号里的小括号b,小括号a里面的完结之后才到下一个分组
```

## 前瞻后顾

要理解?=和?!，首先需要理解前瞻，后顾，负前瞻，负后顾四个概念：

     前瞻： exp1(?=exp2) 查找 exp2 前面的 exp1
     后顾： (?<=exp2)exp1 查找 exp2 后面的 exp1
     负前瞻: exp1(?!exp2) 查找后面不是 exp2 的 exp1
     负后顾: (?<!exp2)exp1 查找前面不是 exp2 的 exp1

```javascript
'中国人'.replace(/(?<=中国)人/, 'rr'); // 匹配中国人中的人，将其替换为rr，结果为 中国rr
'法国人'.replace(/(?<=中国)人/, 'rr'); // 结果为 法国人，因为人前面不是中国，所以无法匹配到
```

### ?:

比较(X)和(?:X)，前者是捕获分组，后者不捕获，区别在于正则表达式匹配输入字符串之后所获得的匹配的（数）组当中没有(?:X)匹配的部分；

```javascript
var mn = 'abcabc'.match(/(?:a)(b)(c)/); //结果 ["abc", "b", "c"]
var mq = 'abcabc'.match(/(a)(b)(c)/); //结果 ["abc", "a", "b", "c"]
```

## 常见的正则

```javascript
/[\u4E00-\u9FA5]/ :匹配中文
/^1[35789]\d{9}$/ :匹配手机号
/<img.+?src=["']?.+?["']?.*?[\/]?>/gi :匹配图片
/<\/?(style|script|i?frame)(.|\n)*>/gi    ：防止srcl注入
^[\u4e00-\u9fa5]{0,}$ ：汉字
^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$：英文和数字：
^.{3,20}$ ： 长度为3-20的所有字符
^[A-Za-z]+$：由26个英文字母组成的字符串
^[A-Z]+$：由26个大写英文字母组成的字符串
^[a-z]+$：由26个小写英文字母组成的字符串
^[A-Za-z0-9]+$：由数字和26个英文字母组成的字符串
^\w+$ 或 ^\w{3,20}$：由数字、26个英文字母或者下划线组成的字符串
^[\u4E00-\u9FA5A-Za-z0-9_]+$：中文、英文、数字包括下划线
^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$：中文、英文、数字但不包括下划线等符号
[^%&',;=?$\x22]+：可以输入含有^%&',;=?$\"等字符
[^~\x22]+：禁止输入含有~的字符
```
